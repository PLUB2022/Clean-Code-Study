# 8장 경계
> 외부 코드를 내 코드에서 호출하는 부분을 경계라고 한다.
## 외부 코드 사용하기
Map 인스턴스 사용 도중 Map 인터페이스가 변경된다면 수정할 코드가 많아진다. (실제로 자바 5에서 인터페이스가 변한 이력이 있음) 따라서 Map을 다음과 같이 사용하면 Map 인터페이스가 변경되더라도 Sensors 클래스 하나만 변경하면 되므로 훨씬 더 좋다.
```Java
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensor.get(id);
    }
}

//이하 생략
```

## 경계 살피고 익히기
학습 테스트(간단한 테스트 케이스를 작성해 외부 코드를 익히는 것)를 수행하라

<br>

## 학습 테스트는 꽁짜 이상이다. 
필요한 지식만 확보하는 손쉬운 방법이다.   
패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.   

<br>

## 아직 존재하지 않는 코드를 사용하기
아직 설계되지 않은 API가 있는 경우 구현은 나중으로 미루고 인터페이스를 정의하라.

<br>

## 깨끗한 경계
경계에 위치하는 코드는 깔끔히 분리하고 기대치를 정의하는 테스트 케이스도 작성한다. 

<br>

# 9장 단위 테스트
## TDD 법칙 세 가지
* 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
* 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
* 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

위 규칙을 따르면 테스트 코드가 너무 방대해진다. -> 심각한 관리 문제 유발   

<br>

## 깨끗한 테스트 코드 유지하기
테스트 코드는 실제 코드 못지 않게 중요하다.   
실제 코드가 변화되면 테스트 코드도 변경해야 하는데 테스트 코드가 지저분할 수록 변경하기 어려워지기 때문.   

<br>

### 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 하지만 테스트 케이스가 있다면 잠정적인 버그들을 커버할 수 있다.   

<br>

## 깨끗한 테스트 코드
**가독성**이 제일 중요하다. 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.   

<br>

### 이중 표준
테스트 코드는 테스트 환경에서 돌아가므로 실제 코드만큼 효율적인 필요는 없다.

<br>

## 테스트 당 assert 하나
### 테스트 당 개념 하나
테스트 함수마다 한 개념만 테스트하라


<br>

## F.I.R.S.T.
**빠르게** 테스트는 빨라야 한다.   
**독립적으로** 각 테스트는 서로 의존하면 안된다.   
**반복가능하게** 테스트는 어떤 환경에서도 반복 가능해야 한다. (실제 환경, QA 환경 등)   
**자가검증하는** 테스트는 부울 값으로 결과를 내야 한다.   
**적시에** 테스트는 적시에 작성해야 한다.   

    테스트 코드 작성 경험이 없어 크게 와닿지 않았습니다 ... 나중에 한 번 더 읽어봐야할 듯 싶네요

<br>

# 10장 클래스
## 클래스 체계
### 캡슐화
캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.   

<br>

## 클래스는 작아야 한다!
클래스 이름은 해당 클래스 책임을 기술해야 한다. 작명은 클래스 크기를 줄이는 첫 번재 관문이다.    

<br>

### 단일 책임 원칙 (SRP)
클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙   

<br>

### 응집도
응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.   

<br>

### 응집도를 유지하면 작은 클래스 여럿이 나온다.
몇몇 함수가 몇몇 변수만 사용한다면 클래스로 분리하라   

<br>

## 변경하기 쉬운 클래스
185 ~ 188의 책 예시 참고

<br>

### 변경으로부터 격리
상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.   

