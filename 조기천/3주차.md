# 클린코드 3주차

## 8 장

### 외부 코드 사용하기

- 외부 코드를 깔끔하게 통합해야 됨
- Map → Generics 사용 → 코드 가독성 높아짐
- 더 좋은 방법은 캡슐화 이용
    - Map 인스턴스를 공개 API 인수로 넘기거나 반환값으로 사용 X

### 경계 살피고 익히기

- 사용할 코드는 테스트를 하는 것이 바람직 함
- 외부 코드는 익히기 어렵고 통합하기 어려움
    
    → 간단한 테스트 케이스를 작성해야함
    
    - 짐 뉴커스는 이를 **학습 테스트**라고 불렀음

### 학습 테스트

- 이해도를 높여주는 정확한 실험임
- 투자하는 노력보다 성과가 더 큼
- 새 버젼이 우리 코드와 호환되지 않으면 학습 테스트가 이를 바로 밝혀냄
- 인터페이스를 사용하는 테스트 케이스가 필요
    - 패키지의 새 버젼으로 이전하기 쉬워짐\\

### 존재하지 않는 코드 사용

- 인터페이스를 구현하면 통제를 할 수 있음
    
    → 코드 가독성이 높아지고 의도가 분명해짐
    
- 경계 테스트 케이스 : API를 올바르게 사용하는지 테스트 가능

### 깨끗한 경계

- 설계가 좋으면 변경하기도 쉬워짐
- 통제 불가능한 외부 코드 < 통제 가능한 우리 코드
- 외부 패키지를 호출하는 코드는 가능한한 줄이자!
    - 새로운 클래스 감싸기
    - Adapter 패턴 사용

# 9 장

### TDD 법칙 3가지

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 샐패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

- 대략적으로 30초 주기로 묶임
- 방대한 테스트 코드는 심각한 관리 문제를 유발

### 깨끗한 테스트 코드

- 테스트 코드가 복잡
    - 실제 코드를 짜는 시간 < 테스트 코드 작성 시간
    - 새 버젼을 출시할 때 테스트 코드를 유지하고 보수하는 비용 증가

- 테스트 슈트 제거?
    - 결함율이 높아짐
    

→ 깨끗하게 테스트 코드를 작성해야 함

- **유연성, 유지보수성 재사용성을 지켜야함**
- 테스트코드는 가독성이 제일 중요!

- BUILD - OPERATE - CHECK 패턴
    - BUILD : 테스트 자료
    - OPERATE : 테스트 자료를 조작
    - CHECK : 조작한 결과가 올바른지 확인

### 좋은 테스트 코드 작성하기

- StringBuffer 사용 금지
    - 메모리 관련 문제, 테스트 코드는 실제와 다르게 자원이 제한적이지 않을 수 있음
- assert 문 줄이기!
    - 테스트 당 하나일 필요는 없지만 최대한 줄이는게 좋음
- 테스트 당 개념 하나
    - 연속으로 테스트 하는 건 피하기!

### FIRST

- Fast 빠르게 : 테스트 코드는 빨라야 함
- Independent 독립적으로 : 테스트 끼리 서로 의존하면 안됨
- Repeatable 반복가능하게 : 어떤 환경에서도 반복 가능
- Self-Validating 자가 검증하는 : 테스트 코드는 Boolean 값으로 결과를 내야 함
- Timely 적시에 : 테스트는 적시에 작성해야 함

### 결론

- 실제 코드의 유연성
- 유지보수성
- 재사용성

→ 보존하고 강화하기 위해서 깨끗한 테스트 코드를 작성하자!

# 10 장

### 깨끗한 클래스

- 캡슐화
    - 공개하지 않는 편이 낫지만, 반드시 숨겨하 한다는 법칙은 아님
    - 캡슐화를 풀어주는 결정은 최후의 수단!
- 클래스는 작아야 한다!
    - 책임이 많으면 안됨
    - 클래스 이름은 해당 클래스의 책임을 기술해야함
    

### 단일 책임 원칙 SRP

- 클래스나 모듈을 변경할 이유가 단 하나여야 함
    - 그러나 SRP는 개발자가 무시하는 규칙 중 하나임
        - 체계적인 소프트웨어보다 돌아가는 소프트웨어에 초점을 맞춤
        - 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다고 우려
    - 규모가 커지면 복잡성이 늘어나기에 체계적인 정리가 필수임
    - 큰 클래스 보다 작은 클래스 여럿으로 이뤄진게 더 바람직함
    - 작은 클래스는 각자 맡은 책임이 하나이며, 변경할 이유가 하나여야함
    - 다른 작은 클래스와 협력해 시스템에 필요한 동작 수행
    

### 응집도

- 인스턴스 변수 수가 작아야 함
- 메서드가 변수를 더 많이 사용할 수록 응집도가 높음
- 응집도가 높은 클래스 → 서로 의존하고 논리적인 단위로 묶임
- 응집도가 높아지도록 변수와 메서드를 적절히 분히래 새로운 클래스 두 세개로 쪼개야 함

### 변경하기 쉬운 클래스

- 대다수의 시스템은 지속적인 변경이 가해짐
- 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춰줌
- 비공개 메서드는 코드를 개선할 잠재적인 여지를 시사함

## OCP

- 확장에 개방적이로 수정에 폐쇄적이다.
- 새 기능을 수정하거나 기존 기능을 변경할때 건드릴 코드가 최소여야 함!
- 시스템을 확장할 뿐, 변경하지는 않는다.

### DIP

- 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙
- 시스템의 결합도를 낮추면 유연성과 재사용성이 높아짐
    
    → 결합도가 낮다는 소리
    
    → 잘 격리되어 있다는 의미
    
- 결합도를 최소로 줄이면 DIP를 따르는 클래스가 나옴